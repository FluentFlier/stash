//Awais have a look at this file

import { spawn } from 'child_process';
import path from 'path';
import { logger } from '../utils/logger.js';


interface WorkflowResult {
    topic: string;
    summary: string;
    folderPath: string;
    tags: string[];
    confidence: number;
}

/**
 * Bridge service to execute Python workflow scripts
 */
export class PythonBridge {
    private scriptPath: string;
    private env: NodeJS.ProcessEnv;

    constructor() {
        // Path to the python script (relative to backend or absolute)
        this.scriptPath = path.resolve(process.cwd(), 'processes/workflow.py');

        // Pass current env + ensure python knows where to find modules
        this.env = {
            ...process.env,
            PYTHONPATH: path.resolve(process.cwd(), 'processes'),
        };
    }

    /**
     * Execute the full workflow for a URL
     */
    async processUrl(url: string): Promise<WorkflowResult> {
        return new Promise((resolve, reject) => {
            logger.info(`[PythonBridge] Starting workflow for: ${url}`);

            const pythonProcess = spawn('python3', [this.scriptPath, url], {
                env: this.env
            });

            let stdoutData = '';
            let stderrData = '';

            pythonProcess.stdout.on('data', (data) => {
                stdoutData += data.toString();
            });

            pythonProcess.stderr.on('data', (data) => {
                stderrData += data.toString();
            });

            pythonProcess.on('close', (code) => {
                if (code !== 0) {
                    logger.error(`[PythonBridge] Process exited with code ${code}`);
                    logger.error(`[PythonBridge] Stderr: ${stderrData}`);
                    return reject(new Error(`Python workflow failed with code ${code}`));
                }

                try {
                    const result = this.parseOutput(stdoutData);
                    resolve(result);
                } catch (error) {
                    logger.error('[PythonBridge] Failed to parse output', error);
                    reject(error);
                }
            });
        });
    }

    /**
     * Parse the stdout from workflow.py to extract JSON result
     */
    private parseOutput(output: string): WorkflowResult {
        // Look for the classification result block
        // It is printed between "CLASSIFICATION RESULT" and separators

        // We can look for the JSON object at the end
        // Logic: Find the last occurrence of "CLASSIFICATION RESULT", then find the JSON after it.

        // Let's try to find the JSON structure by regex or parsing
        const match = output.match(/CLASSIFICATION RESULT\n=+\n({[\s\S]*?})\n=+/);

        if (match && match[1]) {
            try {
                const data = JSON.parse(match[1]);

                // Extract relevant fields
                // The output format from AutoFolderOutput
                const result: WorkflowResult = {
                    topic: data.applied_labels?.domain || 'General', // Fallback? 
                    // Wait, data doesn't distinctly have "topic" and "summary" in the output JSON
                    // The output JSON is the Classification Result (Folder info).
                    // We also need the topic/summary generated by Step 1.
                    // Workflow.py prints paths to topic.txt and summary.txt. We might need to read them?

                    // Actually, let's read the topic/summary from the FILES since workflow.py saves them.
                    // But reading files is async.

                    summary: data.notes || '',
                    folderPath: data.final_path,
                    tags: data.tags || [],
                    confidence: data.confidence || 0
                };

                // We need to read the summary/topic text files to get the actual content
                // The logs inside stdout will tell us where they are:
                // "Topic file: /path/to/topic.txt"

                const topicPathMatch = output.match(/Topic file: (.*)/);
                const summaryPathMatch = output.match(/Summary file: (.*)/);

                if (topicPathMatch) {
                    const fs = require('fs');
                    try {
                        result.topic = fs.readFileSync(topicPathMatch[1].trim(), 'utf-8').trim();
                    } catch (e) { logger.warn('Could not read topic file'); }
                }

                if (summaryPathMatch) {
                    const fs = require('fs');
                    try {
                        result.summary = fs.readFileSync(summaryPathMatch[1].trim(), 'utf-8').trim();
                    } catch (e) { logger.warn('Could not read summary file'); }
                }

                return result;

            } catch (e) {
                throw new Error('Failed to parse JSON result from python output');
            }
        }

        throw new Error('Could not find classification result in output');
    }
}

export const pythonBridge = new PythonBridge();
